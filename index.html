<!DOCTYPE html>
<html lang="zh-Hant">

<head>
  <meta charset="UTF-8" />
  <title>Two Floors + Minimap（1F 保留 server；2F 厚天花只在小地圖隱藏）</title>
  <style>
    body {
      margin: 0;
      overflow: hidden
    }

    canvas {
      display: block
    }

    .hud {
      position: fixed;
      inset: 0;
      pointer-events: none;
      z-index: 3
    }

    .pad {
      position: absolute;
      bottom: 24px;
      left: 24px;
      pointer-events: auto;
      user-select: none;
      display: grid;
      grid-template-columns: 56px 56px 56px;
      grid-template-rows: 56px 56px 56px;
      gap: 8px
    }

    .pad .btn,
    .look-pad .btn,
    .floor-pad .btn {
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      touch-action: none;
      background: rgba(0, 0, 0, .45);
      color: #fff;
      font: 600 14px/1 system-ui, -apple-system, "Segoe UI", Roboto, Arial, "Noto Sans TC";
      border: 1px solid rgba(255, 255, 255, .2);
      border-radius: 12px;
      padding: 10px 12px;
      backdrop-filter: blur(4px);
      transition: transform .06s ease
    }

    .pad .btn {
      font-size: 16px
    }

    .pad .btn:active,
    .pad .btn.active {
      transform: scale(.95);
      background: rgba(0, 0, 0, .6)
    }

    .look-pad {
      position: absolute;
      right: 24px;
      bottom: 24px;
      pointer-events: auto;
      display: grid;
      grid-template-columns: 56px;
      grid-template-rows: 56px 56px;
      gap: 8px
    }

    .floor-pad {
      position: absolute;
      right: 24px;
      top: 24px;
      pointer-events: auto;
      display: grid;
      grid-auto-flow: row;
      gap: 8px
    }

    .hint {
      position: absolute;
      left: 24px;
      bottom: 210px;
      pointer-events: none;
      color: #fff;
      background: rgba(0, 0, 0, .45);
      padding: 8px 10px;
      border-radius: 8px;
      font: 500 13px/1.4 system-ui, -apple-system, "Segoe UI", Roboto, Arial, "Noto Sans TC"
    }

    .label {
      pointer-events: auto
    }

    .minimap-wrap {
      position: fixed;
      right: 16px;
      top: 16px;
      width: 220px;
      height: 220px;
      z-index: 2;
      pointer-events: none;
      border-radius: 12px;
      overflow: hidden;
      box-shadow: 0 8px 24px rgba(0, 0, 0, .35);
      border: 1px solid rgba(255, 255, 255, .25)
    }

    .minimap-hud {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: flex-start;
      justify-content: space-between;
      pointer-events: none;
      font: 600 12px/1 system-ui, -apple-system, "Segoe UI", Roboto, Arial, "Noto Sans TC";
      color: #fff
    }

    .minimap-badge {
      background: rgba(0, 0, 0, .45);
      padding: 6px 8px;
      margin: 8px;
      border-radius: 8px
    }
  </style>
</head>

<body>
  <!-- ===== HUD ===== -->
  <div class="hud">
    <div class="pad" aria-label="Move/Rotate Pad">
      <div></div><button id="btnForward" class="btn" title="前進 (W/↑)">▲</button>
      <div></div>
      <button id="btnRotateLeft" class="btn" title="左轉 (A/←)">◀</button>
      <div></div>
      <button id="btnRotateRight" class="btn" title="右轉 (D/→)">▶</button>
      <div></div>
      <button id="btnBackward" class="btn" title="後退 (S/↓)">▼</button>
      <div></div>
    </div>
    <div class="look-pad">
      <button id="btnLookUp" class="btn" title="抬頭 (Q)">Look ↑</button>
      <button id="btnLookDown" class="btn" title="低頭 (E)">Look ↓</button>
    </div>
    <div class="floor-pad">
      <button id="btnFloor1" class="btn" title="切到 1F (Z)">切到 1F</button>
      <button id="btnFloor2" class="btn" title="切到 2F (X)">切到 2F</button>
    </div>
    <div class="hint">單擊畫面新增標註（跟著樓層）。右上角可切換 1F/2F。小地圖會顯示當前樓層；1F 保留 server；2F 厚天花只在小地圖隱藏。</div>
  </div>

  <!-- ===== 小地圖容器 ===== -->
  <div class="minimap-wrap" id="minimapWrap" aria-label="Top-Down Minimap">
    <div class="minimap-hud">
      <div class="minimap-badge" id="mapBadge">MAP · 1F</div>
    </div>
  </div>

  <script type="module">
    import * as THREE from 'https://esm.sh/three@0.164.1';
    import { GLTFLoader } from 'https://esm.sh/three@0.164.1/examples/jsm/loaders/GLTFLoader.js';
    import { CSS2DRenderer, CSS2DObject } from 'https://esm.sh/three@0.164.1/examples/jsm/renderers/CSS2DRenderer.js';
    import { KTX2Loader } from 'https://esm.sh/three@0.164.1/examples/jsm/loaders/KTX2Loader.js';
    import { MeshoptDecoder } from 'https://esm.sh/three@0.164.1/examples/jsm/libs/meshopt_decoder.module.js';

    // ===== 場景基礎 =====
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xeeeeee);

    const camera = new THREE.PerspectiveCamera(60, innerWidth / innerHeight, 0.1, 1000);
    camera.rotation.order = 'YXZ';

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(innerWidth, innerHeight);
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.4;
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    document.body.appendChild(renderer.domElement);

    // CSS2D（標註層）
    const labelRenderer = new CSS2DRenderer();
    labelRenderer.setSize(innerWidth, innerHeight);
    labelRenderer.domElement.style.position = 'absolute';
    labelRenderer.domElement.style.inset = '0';
    labelRenderer.domElement.style.pointerEvents = 'auto';
    labelRenderer.domElement.style.zIndex = '2';
    document.body.appendChild(labelRenderer.domElement);

    // 燈光
    scene.add(new THREE.HemisphereLight(0xffffff, 0x444444, 1.5));
    scene.add(new THREE.AmbientLight(0xffffff, 0.8));
    const dir = new THREE.DirectionalLight(0xffffff, 2.5);
    dir.position.set(20, 10, 10);
    scene.add(dir);

    // ===== 狀態 =====
    const mouseNDC = new THREE.Vector2(); // 監聽滑鼠事件
    const floors = []; // 每層：{ group, pickables, colliders, roofCandidates, moveBounds, floorY, sceneSize }
    let activeFloorIdx = -1; // 代表尚未選擇

    // Raycasters
    const raycaster = new THREE.Raycaster();  // 一般用的射線檢測
    const occRay = new THREE.Raycaster();  // 專門檢查遮擋用的射線
    const OCC_EPS = 0.04;  // 遮擋檢測時的小偏移量，避免射線卡在物件裡造成誤判

    // 標註
    const tags = []; // { dotObj, cardObj, open, occluded, floorIdx }
    function syncTagVisibility(t) {
      const onThisFloor = (t.floorIdx === activeFloorIdx); // 檢查這個 tag 是否屬於目前啟用的樓層
      t.dotObj.visible = onThisFloor && !t.occluded && !t.open; // 控制 小點（dot 標記）
      t.cardObj.visible = onThisFloor && !t.occluded && t.open; // 控制 卡片（資訊卡）
    }
    function updateTagOcclusion() {
      const floor = floors[activeFloorIdx]; if (!floor) return;
      const { colliders } = floor; if (!colliders.length) return;
      for (const t of tags) {
        if (t.floorIdx !== activeFloorIdx) { t.occluded = true; syncTagVisibility(t); continue; } // 如果這個 tag 不在當前樓層 → 直接設為「被遮擋」，並更新可見性
        t.dotObj.updateWorldMatrix(true, false);
        const worldPos = new THREE.Vector3(); t.dotObj.getWorldPosition(worldPos);
        // 計算 tag.dotObj 在世界座標系的位置
        const dir = worldPos.clone().sub(camera.position); const dist = dir.length();
        if (dist < 1e-4) { t.occluded = false; syncTagVisibility(t); continue; }
        dir.normalize();
        // 用 occRay 做遮擋檢測
        occRay.set(camera.position, dir); occRay.near = 0.001; occRay.far = Math.max(0, dist - OCC_EPS);
        const hits = occRay.intersectObjects(colliders, true); t.occluded = hits.length > 0; syncTagVisibility(t);
      }
    }
    function addTag(worldPos, title = '標註', html = '') {
      const dot = document.createElement('button');
      dot.className = 'label tag-dot'; dot.title = '查看標註'; dot.textContent = 'i';
      dot.style.cssText = 'width:22px;height:22px;border-radius:50%;border:2px solid #fff;background:rgba(40,120,255,.95);color:#fff;font:700 12px/1 system-ui;display:flex;align-items:center;justify-content:center;box-shadow:0 2px 8px rgba(0,0,0,.35);cursor:pointer;z-index:1;';
      const dotObj = new CSS2DObject(dot); dotObj.position.copy(worldPos); scene.add(dotObj);

      const card = document.createElement('div');
      card.className = 'label';
      card.style.cssText = 'min-width:220px;max-width:320px;padding:10px 12px;background:rgba(0,0,0,.72);color:#fff;border-radius:10px;font:500 13px/1.45 system-ui;backdrop-filter:blur(4px);box-shadow:0 10px 24px rgba(0,0,0,.35);z-index:10;';
      card.innerHTML = `
        <div style="display:flex;justify-content:space-between;align-items:center;gap:8px;">
          <strong>${title}</strong>
          <span style="display:flex;gap:6px;">
            <button class="editBtn"   style="all:unset;cursor:pointer;padding:4px 6px;border-radius:6px;background:rgba(255,255,255,.15)">編輯</button>
            <button class="deleteBtn" style="all:unset;cursor:pointer;padding:4px 6px;border-radius:6px;background:rgba(255,80,80,.25)">刪除</button>
            <button class="closeBtn"  style="all:unset;cursor:pointer;padding:4px 6px;border-radius:6px;background:rgba(255,255,255,.15)">關閉</button>
          </span>
        </div>
        <div class="body" style="margin-top:6px">${html}</div>`;
      const cardObj = new CSS2DObject(card); cardObj.position.copy(worldPos).add(new THREE.Vector3(0, 0.3, 0)); cardObj.visible = false; scene.add(cardObj);

      const rec = { dotObj, cardObj, open: false, occluded: false, floorIdx: activeFloorIdx };
      dot.addEventListener('click', ev => { ev.stopPropagation(); rec.open = !rec.open; syncTagVisibility(rec); });
      card.querySelector('.closeBtn')?.addEventListener('click', ev => { ev.stopPropagation(); rec.open = false; syncTagVisibility(rec); });
      card.querySelector('.editBtn')?.addEventListener('click', ev => {
        ev.stopPropagation(); const body = card.querySelector('.body'); const v = prompt('編輯標註內容：', body ? body.innerText : '');
        if (v != null) body.innerHTML = String(v).replace(/\n/g, '<br/>');
      });
      card.querySelector('.deleteBtn')?.addEventListener('click', ev => { ev.stopPropagation(); scene.remove(dotObj); scene.remove(cardObj); dot.remove(); card.remove(); });

      tags.push(rec); syncTagVisibility(rec); return rec;
    }
    function closeAllTags() {
      let closed = false; for (const t of tags) if (t.open) { t.open = false; syncTagVisibility(t); closed = true; } return closed;
    }

    const ktx2 = new KTX2Loader()
      .setTranscoderPath('https://unpkg.com/three@0.164.1/examples/jsm/libs/basis/')  // or 改成你自己主機的路徑
      .detectSupport(renderer);

    // ===== 載入兩層 =====
    const loader = new GLTFLoader();
    // loader.setKTX2Loader(ktx2);        // 讓 GLTFLoader 會解 .ktx2
    loader.setMeshoptDecoder(MeshoptDecoder); // 你之後若有用 Meshopt 也能解
    loader.setKTX2Loader(ktx2);
    ktx2.detectSupport(renderer);

    const EYE_HEIGHT = 1.6;

    // 1F：server_room.glb
    loader.load('models/server_room.glb', (gltf) => {
      const base = gltf.scene;
      const box = new THREE.Box3().setFromObject(base);
      const c = new THREE.Vector3(); box.getCenter(c); base.position.sub(c);
      box.setFromObject(base);
      const sceneSize = new THREE.Vector3(); box.getSize(sceneSize);
      const floorY = -sceneSize.y / 2;

      const f1 = buildFloorFrom(base, floorY, sceneSize, /*floorIdx=*/0);
      floors[0] = f1; f1.group.visible = false; scene.add(f1.group);

      if (activeFloorIdx === -1) {
        activeFloorIdx = 0;
        camera.position.set(0, f1.floorY + EYE_HEIGHT, -1.5);
        updateFloorVisibility();
        initMinimap(f1.sceneSize, f1.floorY);
      }

      f1.group.position.y = f1.floorY + f1.sceneSize.y / 2; // 將地板對齊到 floorY

      relayoutSecondFloorIfNeeded();
    });

    // 2F：meeting_room.glb
    loader.load('models/meeting_room_compressed.glb', (gltf) => {
      const base = gltf.scene;
      const box = new THREE.Box3().setFromObject(base);
      const c = new THREE.Vector3(); box.getCenter(c); base.position.sub(c);
      box.setFromObject(base);
      const sceneSize = new THREE.Vector3(); box.getSize(sceneSize);

      // 疊到 1F 上方（留 0.4m 縫）
      const gap = 0.4;
      const f2FloorY = floors[0] ? floors[0].floorY + floors[0].sceneSize.y + gap : 0;
      // base.position.y += (floors[0] ? floors[0].sceneSize.y + gap : 0);

      const f2 = buildFloorFrom(base, f2FloorY, sceneSize, /*floorIdx=*/1);
      floors[1] = f2; f2.group.visible = false; scene.add(f2.group);

      f2.group.position.y = f2.floorY + f2.sceneSize.y / 2; // 將地板對齊到 floorY

      relayoutSecondFloorIfNeeded();
    });

    // ===== 依樓層建立資料（重點：1F/2F 不同的「天花候選」規則）=====
    function buildFloorFrom(model, floorY, sceneSize, floorIdx) {
      const group = new THREE.Group(); group.add(model);
      const pickables = []; // 可以互動的 mesh 清單
      const colliders = []; // 拿來做碰撞檢查的 mesh 清單
      const roofCandidates = []; // 判斷成「天花板」的 mesh 清單

      model.traverse(o => { // 遍歷模型 → 找到所有 mesh
        if (o.isMesh) { pickables.push(o); colliders.push(o); o.updateMatrixWorld(true); }
      });

      const ceilY = floorY + sceneSize.y; // 這層樓的天花板 Y 高度

      // 規則：1F 保守（避免誤殺 server）；2F 粗暴（貼近天花的一整塊都當天花）
      const THIN_H = Math.min(0.35, sceneSize.y * 0.08); // 薄板判定
      const WIDE_RATIO = 3.0;
      const LARGE_COVER_RATIO = 0.25;
      const CEIL_NEAR_EPS = 0.02;

      model.traverse(o => {
        if (!o.isMesh) return;

        const nameStr = [o.name || '', o.parent?.name || '', o.material?.name || ''].join(' ').toLowerCase();
        const isServerLike = /(server|rack|cabinet)/i.test(nameStr);

        const wb = new THREE.Box3().setFromObject(o);
        const h = wb.max.y - wb.min.y;
        const w = wb.max.x - wb.min.x;
        const d = wb.max.z - wb.min.z;

        if (floorIdx === 1) {
          // 2F：厚天花 → 任何「頂面幾乎貼到天花」的物件，整塊收進 minimap 天花清單
          if (wb.max.y >= ceilY - CEIL_NEAR_EPS) {
            roofCandidates.push(o);
          }
        } else {
          // 1F：只把薄而扁、或名稱明顯是天花/燈具的收進清單；避免 server 被藏
          const isByName = /(roof|ceiling|light|lamp|panel|fixture|grid|duct|vent|beam|led|天花|吊頂|燈)/i.test(nameStr) && !isServerLike;
          const isThinWide = (h <= THIN_H) && ((Math.max(w, d) / Math.max(h, 1e-3)) >= WIDE_RATIO);
          const roomArea = Math.max(1e-3, sceneSize.x * sceneSize.z);
          const isLargeCover = (w * d) / roomArea >= LARGE_COVER_RATIO;
          const isNearCeiling = (wb.max.y >= ceilY - CEIL_NEAR_EPS);

          if ((isByName) || (isNearCeiling && (isThinWide || (isLargeCover && h <= THIN_H * 1.5)))) {
            roofCandidates.push(o);
          }
        }
      });

      // 可移動邊界
      const margin = 0.3;
      const minX = -sceneSize.x / 2 + margin, maxX = sceneSize.x / 2 - margin;
      const minZ = -sceneSize.z / 2 + margin, maxZ = sceneSize.z / 2 - margin;
      const moveBounds = new THREE.Box2(new THREE.Vector2(minX, minZ), new THREE.Vector2(maxX, maxZ)); // 設定玩家在這層樓能走的範圍 (一個 2D 方框)

      return { group, pickables, colliders, roofCandidates, moveBounds, floorY, sceneSize };
    }

    const GAP = 0.4;

    function relayoutSecondFloorIfNeeded() {
      const f1 = floors[0], f2 = floors[1];
      if (!f1 || !f2) return;

      const desiredFloorY = f1.floorY + f1.sceneSize.y + GAP;     // 期望 2F 地板世界座標
      const desiredGroupY = desiredFloorY + f2.sceneSize.y / 2;    // 對應的 group 世界座標

      if (Math.abs(f2.group.position.y - desiredGroupY) > 1e-4) {
        f2.group.position.y = desiredGroupY; // 直接放到正確位置
        f2.floorY = desiredFloorY;           // 記錄正確的地板 Y

        if (activeFloorIdx === 1) {
          camera.position.y = f2.floorY + EYE_HEIGHT; // 若在 2F，同步拉相機
        }
      }
    }

    function updateFloorVisibility() {
      floors.forEach((f, i) => { if (f) f.group.visible = (i === activeFloorIdx); });
      const badge = document.getElementById('mapBadge');
      if (badge) badge.textContent = `MAP · ${activeFloorIdx === 0 ? '1F' : '2F'}`;
      for (const t of tags) syncTagVisibility(t); // 標籤 (tags) 只會在目前樓層顯示
    }

    function switchFloor(idx) {
      if (!floors[idx]) return;
      activeFloorIdx = idx;
      camera.position.y = floors[idx].floorY + EYE_HEIGHT; // 移動攝影機到正確高度
      updateFloorVisibility();
    }

    // ===== 控制 =====
    let moveForward = false, moveBackward = false, rotateLeft = false, rotateRight = false, lookUp = false, lookDown = false;
    let velocity = new THREE.Vector3();
    const speed = 2.0, rotationSpeed = 1.5, lookSpeed = 1.0;
    let moveStartTime = 0, moveInProgress = false, last = performance.now();

    document.addEventListener('keydown', e => {
      if (e.code === 'KeyZ') switchFloor(0);
      if (e.code === 'KeyX') switchFloor(1);
      if (!moveInProgress) {
        switch (e.code) {
          case 'ArrowUp': case 'KeyW': moveForward = true; break;
          case 'ArrowDown': case 'KeyS': moveBackward = true; break;
          case 'ArrowLeft': case 'KeyA': rotateLeft = true; break;
          case 'ArrowRight': case 'KeyD': rotateRight = true; break;
          case 'KeyQ': lookUp = true; break;
          case 'KeyE': lookDown = true; break;
        }
        moveStartTime = performance.now(); moveInProgress = true;
      }
    });
    document.addEventListener('keyup', e => {
      switch (e.code) {
        case 'ArrowUp': case 'KeyW': moveForward = false; break;
        case 'ArrowDown': case 'KeyS': moveBackward = false; break;
        case 'ArrowLeft': case 'KeyA': rotateLeft = false; break;
        case 'ArrowRight': case 'KeyD': rotateRight = false; break;
        case 'KeyQ': lookUp = false; break;
        case 'KeyE': lookDown = false; break;
      }
    });

    function bindHoldButton(id, onDown, onUp) {
      const el = document.getElementById(id); if (!el) return;
      const activate = e => { e.preventDefault(); el.classList.add('active'); onDown(); };
      const deactivate = e => { e && e.preventDefault(); el.classList.remove('active'); onUp(); };
      el.addEventListener('mousedown', activate); addEventListener('mouseup', deactivate);
      el.addEventListener('touchstart', activate, { passive: false }); addEventListener('touchend', deactivate, { passive: false });
      addEventListener('touchcancel', deactivate, { passive: false });
      el.addEventListener('mouseleave', e => { if (e.buttons === 1) deactivate(e); });
    }
    bindHoldButton('btnForward', () => { moveForward = true; moveStartTime = performance.now(); moveInProgress = true; }, () => { moveForward = false; moveInProgress = false; });
    bindHoldButton('btnBackward', () => { moveBackward = true; moveStartTime = performance.now(); moveInProgress = true; }, () => { moveBackward = false; moveInProgress = false; });
    bindHoldButton('btnRotateLeft', () => { rotateLeft = true; moveStartTime = performance.now(); moveInProgress = true; }, () => { rotateLeft = false; moveInProgress = false; });
    bindHoldButton('btnRotateRight', () => { rotateRight = true; moveStartTime = performance.now(); moveInProgress = true; }, () => { rotateRight = false; moveInProgress = false; });
    bindHoldButton('btnLookUp', () => { lookUp = true; moveStartTime = performance.now(); moveInProgress = true; }, () => { lookUp = false; moveInProgress = false; });
    bindHoldButton('btnLookDown', () => { lookDown = true; moveStartTime = performance.now(); moveInProgress = true; }, () => { lookDown = false; moveInProgress = false; });

    const btnF1 = document.getElementById('btnFloor1');
    const btnF2 = document.getElementById('btnFloor2');
    btnF1?.addEventListener('click', () => switchFloor(0));
    btnF2?.addEventListener('click', () => switchFloor(1));

    function willCollide(origin, moveVec) {
      const floor = floors[activeFloorIdx]; if (!floor) return false;
      const colliders = floor.colliders; const PLAYER_RADIUS = 0.30; const RAY_OFFSETS_Y = [0, -0.6, -1.2];
      const len = moveVec.length(); if (len < 1e-6) return false;
      const dir = moveVec.clone().normalize();
      for (const offY of RAY_OFFSETS_Y) {
        const from = new THREE.Vector3(origin.x, origin.y + offY, origin.z);
        const ray = new THREE.Raycaster(from, dir, 0, len + PLAYER_RADIUS);
        const hits = ray.intersectObjects(colliders, true);
        if (hits.length && hits[0].distance <= len + PLAYER_RADIUS) return true;
      }
      return false;
    }

    function updateMovement() {
      const now = performance.now(); const dt = Math.min((now - last) / 1000, 0.1); last = now; // 與上一幀的時間差（秒），限制最大 0.1 秒，避免掉幀時計算過大位移。
      const floor = floors[activeFloorIdx]; if (!floor) return;

      velocity.set(0, 0, 0);
      const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion); forward.y = 0; forward.normalize();
      const backward = forward.clone().negate();

      const elapsed = (now - moveStartTime) / 1000;
      if (elapsed <= 2) { if (moveForward) velocity.addScaledVector(forward, speed * dt); if (moveBackward) velocity.addScaledVector(backward, speed * dt); }
      else { moveInProgress = false; }

      if (!willCollide(camera.position, velocity)) camera.position.add(velocity);

      if (floor.moveBounds) { // 限制玩家不能走出房間邊界
        camera.position.x = Math.min(floor.moveBounds.max.x, Math.max(floor.moveBounds.min.x, camera.position.x));
        camera.position.z = Math.min(floor.moveBounds.max.y, Math.max(floor.moveBounds.min.y, camera.position.z));
      }

      if (rotateLeft) camera.rotation.y += rotationSpeed * dt;
      if (rotateRight) camera.rotation.y -= rotationSpeed * dt;
      if (lookUp) { camera.rotation.x += lookSpeed * dt; if (camera.rotation.x > Math.PI / 2) camera.rotation.x = Math.PI / 2; }
      if (lookDown) { camera.rotation.x -= lookSpeed * dt; if (camera.rotation.x < -Math.PI / 2) camera.rotation.x = -Math.PI / 2; }
      camera.rotation.z = 0; // 確保不會「歪頭」
    }

    // 點擊新增標註（屬於當前樓層）
    document.addEventListener('click', e => {
      const floor = floors[activeFloorIdx]; if (!floor) return;
      const inLabel = !!e.target.closest?.('.label'); const inHUD = !!e.target.closest?.('.hud');
      if (!inLabel) { const closed = closeAllTags(); if (closed) return; }
      if (inHUD || inLabel) return;

      // 把滑鼠點擊的座標轉換成 NDC (Normalized Device Coordinates)，範圍 [-1, 1]
      const rect = renderer.domElement.getBoundingClientRect();
      mouseNDC.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
      mouseNDC.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
      raycaster.setFromCamera(mouseNDC, camera);
      const hits = raycaster.intersectObjects(floor.pickables, true); if (!hits.length) return;

      const hit = hits[0];
      // 點擊到的世界座標
      const pos = hit.point.clone().add(hit.face?.normal?.clone().multiplyScalar(0.02) || new THREE.Vector3());
      const text = prompt('輸入標註內容：', '這裡是我的標註'); if (text === null) return;
      const content = (text.trim() === '' ? '（未命名標註）' : text).replace(/\n/g, '<br/>');
      addTag(pos, '標註', content);
    });

    // ===== 小地圖 =====
    let miniRenderer, miniCam;
    const playerMarkers = [null, null]; // 0: 1F, 1: 2F（各自獨立）
    const MINIMAP_SIZE = 220, MINIMAP_SCALE = 1.2;

    // 建立不同顏色的玩家箭頭（只給小地圖圖層用，且永遠浮在最上層）
    function makePlayerMarker(color = 0x0080ff) {
      const coneGeo = new THREE.ConeGeometry(0.24, 0.30, 16);
      const coneMat = new THREE.MeshBasicMaterial({ color });
      // 不參與深度測試，永遠顯示在最上層
      coneMat.depthTest = false;
      coneMat.depthWrite = false;

      const m = new THREE.Mesh(coneGeo, coneMat);
      m.rotation.x = Math.PI / 2;   // 平躺
      m.layers.set(2);              // 小地圖使用圖層
      m.renderOrder = 999;          // 確保不被遮擋
      scene.add(m);
      return m;
    }

    function initMinimap(sceneSize, floorY) {
      miniRenderer = new THREE.WebGLRenderer({ antialias: true, alpha: true }); // 背景透明，可以疊在 HUD 上
      miniRenderer.setSize(MINIMAP_SIZE, MINIMAP_SIZE);
      miniRenderer.outputColorSpace = THREE.SRGBColorSpace;
      miniRenderer.setClearColor(0x000000, 0.0);
      const wrap = document.getElementById('minimapWrap');
      wrap.prepend(miniRenderer.domElement);

      const halfW = (sceneSize.x * 0.5) * MINIMAP_SCALE;
      const halfH = (sceneSize.z * 0.5) * MINIMAP_SCALE;
      // halfW / halfH：決定小地圖顯示的場景範圍
      miniCam = new THREE.OrthographicCamera(-halfW, halfW, halfH, -halfH, 0.1, 1000);
      // 小地圖相機位置固定在樓層正上方
      miniCam.position.set(0, floorY + Math.max(6, sceneSize.y * 2.5), 0);
      // 把小地圖「北方」設為 -Z 俯視當前樓層
      miniCam.up.set(0, 0, -1); miniCam.lookAt(new THREE.Vector3(0, floorY, 1));

      // 主相機與小地圖相機層設定
      camera.layers.enable(0);
      miniCam.layers.enable(0);
      miniCam.layers.enable(2); // 前面有 m.layers.set(2); 小地圖使用圖層
    }

    const MINIMAP_CLIP_HEIGHT_2F = 2;

    function renderMinimap() {
      if (!miniRenderer || !miniCam || !floors.length) return;

      // 目前樓層
      const cur = floors[activeFloorIdx] ?? floors[0];
      if (!cur) return;

      // 1) 依當前樓層大小調整視錐
      const halfW = (cur.sceneSize.x * 0.5) * MINIMAP_SCALE;
      const halfH = (cur.sceneSize.z * 0.5) * MINIMAP_SCALE;
      if (miniCam.left !== -halfW || miniCam.right !== halfW ||
        miniCam.top !== halfH || miniCam.bottom !== -halfH) {
        miniCam.left = -halfW; miniCam.right = halfW;
        miniCam.top = halfH; miniCam.bottom = -halfH;
        miniCam.updateProjectionMatrix();
      }
      // 讓小地圖俯視目前樓層
      miniCam.lookAt(new THREE.Vector3(0, cur.floorY, 1));

      // 2) 各樓層各自的玩家箭頭（1F 藍、2F 橘），且只顯示當前樓層
      for (let i = 0; i < 2; i++) {
        if (!playerMarkers[i] && floors[i]) {
          playerMarkers[i] = makePlayerMarker(i === 0 ? 0x0080ff : 0xff8c00);
        }
        const m = playerMarkers[i];
        if (!m || !floors[i]) continue;

        const baseY = floors[i].floorY;
        m.position.set(camera.position.x, baseY + 0.05, camera.position.z);
        m.rotation.z = -camera.rotation.y;
        m.visible = (i === activeFloorIdx);
      }

      // 3) 暫時隱藏非當前樓層
      const prev = new Map();
      floors.forEach((f, i) => {
        if (i !== activeFloorIdx && f?.group) { prev.set(f.group, f.group.visible); f.group.visible = false; }
      });

      // 4) 2F 厚天花用 clipping plane 切掉（只在小地圖）
      if (activeFloorIdx === 1) {
        // 如果在 2F，為了避免天花板擋住視線，用 clipping plane 把 cutY 以上的部分切掉
        const cutY = cur.floorY + MINIMAP_CLIP_HEIGHT_2F;
        miniRenderer.localClippingEnabled = true;
        miniRenderer.clippingPlanes = [new THREE.Plane(new THREE.Vector3(0, -1, 0), cutY)];
      } else {
        miniRenderer.clippingPlanes = [];
      }

      // 5) （可選）把偵測到的天花/燈具暫時關掉
      for (const m of (cur.roofCandidates ?? [])) { prev.set(m, m.visible); m.visible = false; }

      // 6) 渲染小地圖
      miniRenderer.render(scene, miniCam);

      // 7) 還原狀態
      for (const [obj, vis] of prev) obj.visible = vis;
      miniRenderer.clippingPlanes = [];
    }

    // 視窗縮放
    addEventListener('resize', () => {
      camera.aspect = innerWidth / innerHeight; camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight); labelRenderer.setSize(innerWidth, innerHeight);
    });

    // 迴圈
    function animate() {
      requestAnimationFrame(animate);
      updateMovement();
      updateTagOcclusion();
      renderer.render(scene, camera);
      labelRenderer.render(scene, camera);
      renderMinimap();
    }
    animate();
  </script>
</body>

</html>